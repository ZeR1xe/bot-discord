import discord
from discord.ext import commands
import yt_dlp
import asyncio
import random
from discord.ui import View, Select  
import re 
import requests
import aiohttp
import websockets
import json
import os
from dotenv import load_dotenv, find_dotenv

load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

class MyBot(discord.Client):
    async def on_ready(self):
        print(f"‚úÖ Connect√© en tant que {self.user}")

intents = discord.Intents.default()
bot = MyBot(intents=intents)

if TOKEN:
    bot.run(TOKEN)
else:
    print("‚ùå Token Discord introuvable !")

if not TOKEN:
    print("‚ùå ERREUR: Le token Discord est manquant ou vide !")
    print("üí° V√©rifie que DISCORD_TOKEN est bien d√©fini dans Railway.")
else:
    print("‚úÖ Token r√©cup√©r√© avec succ√®s !")

# ‚úÖ Configuration des intents
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True
intents.guild_messages = True
intents.reactions = True

# ‚úÖ Cr√©ation du bot
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

# ‚úÖ IDs du serveur et des salons (√† remplacer avec les vrais)
GUILD_ID = 1339249351779684422
CHANNEL_RULES_ID = 1339249352031469605
CHANNEL_ROLES_ID = 1339249352031469607 # ‚úÖ AJOUTE UN ID VALIDE
ROLE_ID = 1339249351779684425
WELCOME_CHANNEL_ID = 1339249352031469606  # ID du salon de bienvenue

# ‚úÖ IDs des r√¥les
roles_info = {
    "üë¶üèΩ- Mineur Gar√ßon": 1339281414968840246,
    "üëßüèΩ -Mineur Fille": 1339281631491522580,
    "üë©- Majeur Fille": 1339281759941955727,
    "üßî-Majeur Homme": 1339282075311935499,
    "Twitch üé•": 1339282319634337822,
    "YouTube üì∫": 1339282410675638392,
    "TikTok üé∂": 1339282470264115344,
    "Giveaways üéÅ": 1339282525281058876
}

# Fonction pour extraire proprement l'√©moji et le texte du r√¥le
def extract_emoji_and_label(role_name):
    match = re.match(r"([\U0001F300-\U0001FAD6\U0001F600-\U0001F64F\U0001F680-\U0001F6FF\U0001F1E0-\U0001F1FF\U00002600-\U000026FF]+)?\s?(.+)", role_name)
    if match:
        emoji, label = match.groups()
        return emoji, label
    return None, role_name

class RoleSelect(Select):
    def __init__(self):
        options = []
        for role_name, role_id in roles_info.items():
            emoji, label = extract_emoji_and_label(role_name)

            # V√©rification si l'√©moji est valide pour Discord
            try:
                option = discord.SelectOption(
                    label=label,
                    description=f"Obtenez ou retirez le r√¥le {label}",
                    emoji=emoji if emoji else None,
                    value=str(role_id)
                )
                options.append(option)
            except discord.errors.HTTPException:
                print(f"‚ö†Ô∏è Erreur avec l'√©moji : {emoji} pour le r√¥le {label}")

        super().__init__(
            placeholder="üé≠ Choisissez un r√¥le...",
            min_values=1,
            max_values=1,
            options=options,
            custom_id="role_select"
        )

    async def callback(self, interaction: discord.Interaction):
        role_id = int(self.values[0])
        role = interaction.guild.get_role(role_id)

        if not role:
            await interaction.response.send_message("‚ùå R√¥le introuvable.", ephemeral=True)
            return

        if role in interaction.user.roles:
            await interaction.user.remove_roles(role)
            await interaction.response.send_message(
                f"‚ùå {interaction.user.mention}, vous avez retir√© le r√¥le **{role.name}**.",
                ephemeral=True
            )
        else:
            await interaction.user.add_roles(role)
            await interaction.response.send_message(
                f"‚úÖ {interaction.user.mention}, vous avez re√ßu le r√¥le **{role.name}** !",
                ephemeral=True
            )

class RoleView(View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(RoleSelect())

@bot.command()
async def roles(ctx):
    """Envoie le menu des r√¥les dans le salon d√©fini."""
    await ctx.send("üõ†Ô∏è La commande `roles` a bien √©t√© ex√©cut√©e ! V√©rification en cours...")

    channel = bot.get_channel(CHANNEL_ROLES_ID)

    if not channel:
        await ctx.send("‚ùå Salon de r√¥les introuvable. V√©rifiez `CHANNEL_ROLES_ID` et les permissions.")
        return

    # Suppression des anciens messages
    async for message in channel.history(limit=10):
        if message.author == bot.user:
            await message.delete()

    embed = discord.Embed(
        title="üé≠ **Choisissez vos r√¥les !**",
        description="üîπ S√©lectionnez un r√¥le dans le menu d√©roulant ci-dessous pour l'obtenir ou le retirer.\n"
                    "üîπ Vous pouvez changer de r√¥le √† tout moment !",
        color=discord.Color.blue()
    )
    embed.set_footer(text="Syst√®me de r√¥les interactif üé≠")

    view = RoleView()
    await channel.send(embed=embed, view=view)
    await ctx.send("‚úÖ Message de s√©lection des r√¥les envoy√© avec succ√®s !")

# ------------------------- √âV√âNEMENT : BOT PR√äT -------------------------
@bot.event
async def on_ready():
    print(f"‚úÖ {bot.user} est connect√© !")

    # ‚úÖ Enregistrer la vue apr√®s que le bot soit pr√™t
    asyncio.create_task(register_views())

    # ‚úÖ Envoie automatique du r√®glement
    guild = bot.get_guild(GUILD_ID)
    if guild:
        await send_rules_channel(guild)

async def register_views():
    await bot.wait_until_ready()  # ‚úÖ Attend que le bot soit totalement pr√™t
    bot.add_view(RoleView())  # ‚úÖ Ajoute la vue proprement

# ------------------------- MESSAGE DE R√àGLEMENT -------------------------
async def send_rules_channel(guild):
    channel = guild.get_channel(CHANNEL_RULES_ID)
    if channel:
        embed = discord.Embed(title="üìú R√®glement du Serveur", color=discord.Color.red())
        embed.add_field(name="1Ô∏è‚É£ Respect", value="Respectez tous les membres.", inline=False)
        embed.add_field(name="2Ô∏è‚É£ Pas de spam", value="√âvitez le spam et la pub.", inline=False)
        embed.add_field(name="3Ô∏è‚É£ Contenu appropri√©", value="Pas de contenu inappropri√©.", inline=False)
        embed.set_footer(text="R√©agissez ‚úÖ pour accepter le r√®glement et obtenir le r√¥le üë• - Membres")

        message = await channel.send(embed=embed)
        await message.add_reaction("‚úÖ")
        print("üìú Message de r√®glement envoy√©.")
    else:
        print("‚ùå Le salon de r√®glement n'a pas √©t√© trouv√©.")

# ------------------------- AJOUT DE R√îLE VIA R√âACTION -------------------------
# ‚úÖ ID du salon des logs
LOGS_CHANNEL_ID = 1339249352824328286

async def log_reaction_action(action, member):
    """Envoie un message dans le salon de logs quand quelqu'un ajoute ou retire la r√©action."""
    guild = bot.get_guild(GUILD_ID)
    if not guild:
        return

    logs_channel = bot.get_channel(LOGS_CHANNEL_ID)
    if logs_channel:
        embed = discord.Embed(
            title="üìú Log de R√©action",
            description=f"{member.mention} {action} la r√©action ‚úÖ au r√®glement.",
            color=discord.Color.blue()
        )
        embed.set_footer(text=f"ID: {member.id}")
        await logs_channel.send(embed=embed)

@bot.event
async def on_raw_reaction_add(payload):
    if payload.guild_id is None:
        return  # Ignore les r√©actions en MP

    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return

    if payload.channel_id == CHANNEL_RULES_ID and str(payload.emoji) == "‚úÖ":
        member = guild.get_member(payload.user_id)
        role = guild.get_role(ROLE_ID)

        if member and role and not member.bot:
            try:
                await member.add_roles(role)
                print(f"‚úÖ {member} a accept√© le r√®glement et re√ßu le r√¥le {role.name}.")
                await log_reaction_action("a ajout√©", member)
            except discord.Forbidden:
                print("‚ùå Permission refus√©e pour ajouter le r√¥le.")
            except discord.HTTPException as e:
                print(f"‚ùå Erreur HTTP : {e}")

@bot.event
async def on_raw_reaction_remove(payload):
    if payload.guild_id is None:
        return  # Ignore les r√©actions en MP

    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return

    if payload.channel_id == CHANNEL_RULES_ID and str(payload.emoji) == "‚úÖ":
        member = guild.get_member(payload.user_id)
        role = guild.get_role(ROLE_ID)

        if member and role and not member.bot:
            try:
                await member.remove_roles(role)
                print(f"‚ùå {member} a retir√© la r√©action et perdu le r√¥le {role.name}.")
                await log_reaction_action("a retir√©", member)
            except discord.Forbidden:
                print("‚ùå Permission refus√©e pour retirer le r√¥le.")
            except discord.HTTPException as e:
                print(f"‚ùå Erreur HTTP : {e}")


# ------------------------- COMMANDES -------------------------
@bot.command()
async def ping(ctx):
    """R√©pond avec 'Pong !'."""
    await ctx.send("üèì Pong !")

@bot.command()
async def test_role(ctx, member: discord.Member):
    """Ajoute un r√¥le manuellement √† un membre."""
    role = ctx.guild.get_role(ROLE_ID)
    if role:
        try:
            await member.add_roles(role)
            await ctx.send(f"‚úÖ {member.mention} a re√ßu le r√¥le {role.name}.")
        except discord.Forbidden:
            await ctx.send("‚ùå Le bot n'a pas la permission d'ajouter ce r√¥le.")
        except discord.HTTPException as e:
            await ctx.send(f"‚ùå Erreur HTTP : {e}")
    else:
        await ctx.send("‚ùå Le r√¥le n'existe pas.")

@bot.command()
async def exclure(ctx, user: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
    """Exclut un utilisateur du serveur avec notification et log."""
    allowed_roles = {
        1339249351788335279,  # Admins
        1339249351788335277,  # Mod√©rateurs
        1339249351788335276,  # Mod√©rateurs Test
    }

    if not any(role.id in allowed_roles for role in ctx.author.roles):
        await ctx.send("‚ùå Vous n'avez pas la permission d'utiliser cette commande.")
        return

    # üì© Envoi du MP avant l'exclusion
    try:
        embed_mp = discord.Embed(
            title="üìú Vous avez √©t√© exclu",
            description=f"Vous avez √©t√© **exclu** du serveur **{ctx.guild.name}** par {ctx.author.mention}.",
            color=discord.Color.red()
        )
        embed_mp.add_field(name="üìå Raison :", value=reason, inline=False)
        embed_mp.set_footer(text="Si vous pensez que c'est une erreur, vous pouvez contacter : jielzer1xe_.\n"
                                 "Vous pouvez rejoindre le serveur √† nouveau ici : https://discord.gg/mbPRghyN")

        await user.send(embed=embed_mp)
    except discord.Forbidden:
        await ctx.send("‚ö†Ô∏è Impossible d'envoyer un message priv√© √† cet utilisateur.")

    # üö™ Exclusion de l'utilisateur
        await user.kick(reason=reason)



    # üìù Logs dans le salon üíæ„Éªlogs-discord
    log_channel = bot.get_channel(1339249352824328286)
    if log_channel:
        embed_logs = discord.Embed(
            title="üö® Exclusion d'un membre",
            description=f"**{user.mention}** a √©t√© exclu du serveur.",
            color=discord.Color.orange()
        )
        embed_logs.add_field(name="üë§ Utilisateur :", value=f"{user} ({user.id})", inline=False)
        embed_logs.add_field(name="üëÆ‚Äç‚ôÇÔ∏è Exclu par :", value=f"{ctx.author.mention}", inline=False)
        embed_logs.add_field(name="üìå Raison :", value=reason, inline=False)
        embed_logs.set_footer(text=f"Date : {ctx.message.created_at.strftime('%d/%m/%Y %H:%M:%S')}")
        
        await log_channel.send(embed=embed_logs)

@bot.command()
async def bannir(ctx, user: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
    """Bannit un utilisateur du serveur avec logs et message priv√©."""
    
    # R√¥les autoris√©s √† utiliser la commande
    allowed_roles = [1339249351788335279, 1339249351788335277, 1339249351788335276]  # IDs des r√¥les

    if not any(role.id in allowed_roles for role in ctx.author.roles):
        await ctx.send("‚ùå Vous n'avez pas la permission d'utiliser cette commande.")
        return
    
    try:
        # üì© Message priv√© √† l'utilisateur avant le bannissement
        embed_mp = discord.Embed(title="üìú Vous avez √©t√© banni", color=discord.Color.red())
        embed_mp.add_field(name="üö™ Serveur", value="**Serveur de jielzer1xe_**", inline=False)
        embed_mp.add_field(name="üìå Raison", value=f"```{reason}```", inline=False)
        embed_mp.add_field(
            name="‚ö†Ô∏è Si vous pensez que c'est une erreur",
            value="Vous pouvez contacter : **jielzer1xe_**",
            inline=False
        )
        
        try:
            await user.send(embed=embed_mp)  # Envoie du MP avant le ban
        except discord.HTTPException:
            pass  # Ignore si le MP ne peut pas √™tre envoy√©
        
        # üö™ Bannissement de l'utilisateur
        await user.ban(reason=reason)

        # üìù Logs dans le salon "üíæ„Éªlogs-discord"
        logs_channel = bot.get_channel(1339249352824328286)  # ID du salon logs
        if logs_channel:
            embed_logs = discord.Embed(title="üî® Bannissement", color=discord.Color.red())
            embed_logs.add_field(name="üë§ Utilisateur", value=user.mention, inline=False)
            embed_logs.add_field(name="üëÆ‚Äç‚ôÇÔ∏è Mod√©rateur", value=ctx.author.mention, inline=False)
            embed_logs.add_field(name="üìå Raison", value=f"```{reason}```", inline=False)
            embed_logs.set_footer(text=f"ID utilisateur : {user.id}")
            await logs_channel.send(embed=embed_logs)

    except discord.Forbidden:
        await ctx.send("‚ùå Je n'ai pas la permission de bannir cet utilisateur.")
    except Exception as e:
        await ctx.send(f"‚ùå Erreur inattendue : {e}")

@bot.command()
async def debannir(ctx, user_id: int):
    """D√©bannit un utilisateur √† partir de son ID avec logs et MP."""
    allowed_roles = ["üõ°Ô∏è - Admins", "üõ†Ô∏è - Mod√©rateurs", "üîé - Mod√©rateurs Test"]
    if not any(role.name in allowed_roles for role in ctx.author.roles):
        await ctx.send("‚ùå Vous n'avez pas la permission d'utiliser cette commande.")
        return

    try:
        # R√©cup√©rer la liste des bannis
        banned_users = [entry async for entry in ctx.guild.bans()]
        user = discord.utils.find(lambda u: u.user.id == user_id, banned_users)

        if user:
            await ctx.guild.unban(user.user)

            # Message priv√© √† l'utilisateur
            try:
                embed = discord.Embed(title="üîì Vous avez √©t√© d√©banni", color=discord.Color.green())
                embed.add_field(name="üìå Serveur :", value=f"**{ctx.guild.name}**", inline=False)
                embed.add_field(name="üë§ D√©banni par :", value=ctx.author.mention, inline=False)
                await user.user.send(embed=embed)
            except:
                pass  # Si l'utilisateur ne peut pas recevoir de MP

            # Logs dans le salon
            log_channel = bot.get_channel(1339249352824328286)  # ID du salon logs
            if log_channel:
                embed_log = discord.Embed(title="üìú Un utilisateur a √©t√© d√©banni", color=discord.Color.green())
                embed_log.add_field(name="üë§ Utilisateur :", value=f"{user.user.mention} ({user.user.id})", inline=False)
                embed_log.add_field(name="üîß Staff :", value=ctx.author.mention, inline=False)
                await log_channel.send(embed=embed_log)

        else:
            await ctx.send("‚ùå Utilisateur non trouv√© dans la liste des bannis.")

    except discord.Forbidden:
        await ctx.send("‚ùå Je n'ai pas la permission de d√©bannir des utilisateurs.")
    except Exception as e:
        await ctx.send(f"‚ùå Erreur inattendue : {e}")

@bot.command()
async def bannis(ctx):
    """Affiche la liste des utilisateurs bannis avec leur ID et raison de ban."""
    allowed_roles = [1339249351788335279, 1339249351788335277, 1339249351788335276]
    
    # V√©rification des r√¥les
    if not any(role.id in allowed_roles for role in ctx.author.roles):
        await ctx.send("‚ùå Vous n'avez pas la permission d'utiliser cette commande.")
        return

    try:
        banned_users = [entry async for entry in ctx.guild.bans()]
        
        if not banned_users:
            await ctx.send("‚úÖ Aucun utilisateur n'est actuellement banni.")
            return

        # Cr√©ation d'un embed propre
        embed = discord.Embed(title="üìú Liste des utilisateurs bannis", color=discord.Color.red())

        for entry in banned_users:
            user = entry.user
            reason = entry.reason if entry.reason else "Aucune raison sp√©cifi√©e"
            embed.add_field(
                name=f"üë§ {user.name}#{user.discriminator} ({user.id})",
                value=f"üìå **Raison** : {reason}",
                inline=False
            )

        await ctx.send(embed=embed)

    except discord.Forbidden:
        await ctx.send("‚ùå Je n'ai pas la permission de voir la liste des bannis.")
    except Exception as e:
        await ctx.send(f"‚ùå Erreur inattendue : {e}")
@bot.event
async def on_member_join(member):
    guild = member.guild
    channel = bot.get_channel(WELCOME_CHANNEL_ID)

    # R√©cup√©ration des invitations pour voir celle utilis√©e
    invites = await guild.invites()
    invite_used = None
    for invite in invites:
        if invite.uses > 0:  # V√©rifie si l'invitation a √©t√© utilis√©e
            invite_used = invite
            break

    # Date de cr√©ation du compte
    account_creation_date = member.created_at.strftime("%d/%m/%Y")

    # Nombre total de membres
    total_members = guild.member_count

    # Cr√©ation de l'embed de bienvenue
    embed = discord.Embed(title="Bienvenue sur JL Community", color=discord.Color.blue())
    embed.description = (
        f"{member.mention} vient de nous rejoindre gr√¢ce √† "
        f"{f'lien d‚Äôinvitation **{invite_used.code}**' if invite_used else 'un lien inconnu'}.\n"
        f"üìÖ **Son compte a √©t√© cr√©√© le** : {account_creation_date}.\n"
        f"üë§ **C'est la premi√®re fois qu'il nous rejoint.**\n"
        f"üìå **Nous sommes maintenant {total_members} membres !**"
     )

    # Ajout de la photo de profil du membre
    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)

    await channel.send(embed=embed)              

@bot.command()
async def clear(ctx, limit: int = 100):
    """Supprime un nombre de messages sp√©cifi√©."""
    
    allowed_roles = [
        1339249351788335279,  # ID du r√¥le "üõ°Ô∏è - Admins"
        1339249351788335277,  # ID du r√¥le "üõ†Ô∏è - Mod√©rateurs"
        1339249351788335276   # ID du r√¥le "üîé - Mod√©rateurs Test"
    ]
    
    if not any(role.id in allowed_roles for role in ctx.author.roles):
        await ctx.send("‚ùå Vous n'avez pas la permission d'utiliser cette commande.")
        return
    
    try:
        deleted = await ctx.channel.purge(limit=limit)
        log_channel = bot.get_channel(1339249352824328286)  # ID du salon üíæ„Éªlogs-discord
        
        # Message de confirmation dans le salon
        await ctx.send(f"‚úÖ {len(deleted)} messages supprim√©s.", delete_after=5)
        
        # Envoi du log
        if log_channel:
            embed = discord.Embed(
                title="üóëÔ∏è Suppression de messages",
                description=f"{ctx.author.mention} a supprim√© `{len(deleted)}` messages dans {ctx.channel.mention}.",
                color=discord.Color.orange(),
                timestamp=ctx.message.created_at
            )
            embed.set_footer(text=f"ID de {ctx.author}", icon_url=ctx.author.avatar.url)
            await log_channel.send(embed=embed)
    
    except discord.Forbidden:
        await ctx.send("‚ùå Je n'ai pas la permission de supprimer des messages.")
    except Exception as e:
        await ctx.send(f"‚ùå Erreur inattendue : {e}")

ticket_categories = {
    "üîß Support": "Besoin d'aide avec un probl√®me ?",
    "üí° Suggestions": "Proposez une id√©e pour am√©liorer le serveur !",
    "‚ö†Ô∏è Signalement": "Signalez un comportement inappropri√©."
}

class TicketSelect(Select):
    def __init__(self):
        options = [
            discord.SelectOption(label=key, description=value)
            for key, value in ticket_categories.items()
        ]
        super().__init__(placeholder="Fais un choix", options=options)

    async def callback(self, interaction: discord.Interaction):
        guild = interaction.guild
        member = interaction.user
        category = discord.utils.get(guild.categories, id=1339249352681459811)  # ID de la cat√©gorie "üé´„Éªtickets"
        if not category:
            await interaction.response.send_message("Cat√©gorie des tickets non trouv√©e.", ephemeral=True)
            return

        ticket_channel = await guild.create_text_channel(
            name=f"ticket-{member.name}",
            category=category,
            overwrites={
                guild.default_role: discord.PermissionOverwrite(view_channel=False),
                member: discord.PermissionOverwrite(view_channel=True, send_messages=True),
                discord.utils.get(guild.roles, name="üõ°Ô∏è - Admins"): discord.PermissionOverwrite(view_channel=True, send_messages=True),
                discord.utils.get(guild.roles, name="üõ†Ô∏è - Mod√©rateurs"): discord.PermissionOverwrite(view_channel=True, send_messages=True),
                discord.utils.get(guild.roles, name="üîé - Mod√©rateurs Test"): discord.PermissionOverwrite(view_channel=True, send_messages=True)
            }
        )

        staff_role = discord.utils.get(guild.roles, id=1343603906768408597)  # ID du r√¥le "üõ†Ô∏è √âquipe Staff"
        embed = discord.Embed(
            title="Ticket Ouvert",
            description=f"{member.mention} a ouvert un ticket pour {self.values[0]}.",
            color=discord.Color.green()
        )
        embed.add_field(name="Support", value=f"{staff_role.mention}, un membre a besoin d'aide !", inline=False)
        await ticket_channel.send(embed=embed)
        await interaction.response.send_message(f"Votre ticket a √©t√© cr√©√© : {ticket_channel.mention}", ephemeral=True)

class TicketView(View):
    def __init__(self):
        super().__init__()
        self.add_item(TicketSelect())

@bot.event
async def on_ready():
    print(f"Connect√© en tant que {bot.user}")
    await bot.wait_until_ready()

@bot.command()
async def setup_ticket(ctx):
    channel = ctx.channel
    embed = discord.Embed(title="Tickets", description="Utilisez ce menu pour cr√©er un ticket et contacter le staff.", color=discord.Color.green())
    await channel.purge()
    await channel.send(embed=embed, view=TicketView())
    await ctx.send("Message de ticket envoy√©.", delete_after=5)

@bot.command()
async def close(ctx):
    if ctx.channel.category and ctx.channel.category.id == 1339249352681459811:
        await ctx.send("Fermeture du ticket dans 5 secondes...")
        await asyncio.sleep(5)
        await ctx.channel.delete()
    else:
        await ctx.send("Cette commande ne peut √™tre utilis√©e que dans un salon de ticket.")

@bot.command()
async def lien(ctx):
    embed = discord.Embed(title="üìå Mes R√©seaux Sociaux", color=discord.Color.blue())
    embed.add_field(name="üì∫ Twitch", value="[jlzer1xe](https://www.twitch.tv/jlzer1xe)", inline=False)
    embed.add_field(name="üéµ TikTok", value="[jl_zer1xe](https://www.tiktok.com/@jl_zer1xe)", inline=False)
    embed.add_field(name="‚ñ∂Ô∏è YouTube", value="[jlzer1xe](https://www.youtube.com/@jlzer1xe)", inline=False)
    embed.set_footer(text="N'h√©site pas √† me suivre pour ne rien rater !")

    await ctx.send(embed=embed)
    # Liste de blagues
blagues = [
    "Pourquoi les plongeurs plongent-ils toujours en arri√®re et jamais en avant ? Parce que sinon ils tombent dans le bateau.",
    "Quel est le comble pour un √©lectricien ? Ne pas √™tre au courant.",
    "Pourquoi est-ce que les poissons n'aiment pas l'ordinateur ? Parce qu'ils ont peur des hame√ßons.",
    "Quelle est la meilleure punition pour un √©lectricien ? Le mettre au courant.",
    "Pourquoi Napol√©on n'a jamais d√©m√©nag√© ? Parce qu'il avait un Bonaparte."
]

@bot.command()
async def blague(ctx):
    """Envoie une blague al√©atoire sous forme d'embed."""
    blague = random.choice(blagues)
    print(f"Blague s√©lectionn√©e : {blague}")  # V√©rifie dans la console

    embed = discord.Embed(title="üòÇ Blague du jour", description=blague, color=discord.Color.blue())
    embed.set_footer(text=f"Demand√© par {ctx.author.name}", icon_url=ctx.author.avatar.url)

    await ctx.send(embed=embed)

@bot.command()
async def avatar(ctx, membre: discord.Member = None):
    """Affiche l'avatar du membre mentionn√© ou du demandeur."""
    membre = membre or ctx.author  # Si aucun membre n'est mentionn√©, prendre l'auteur
    embed = discord.Embed(title=f"Avatar de {membre.name}", color=discord.Color.blue())
    embed.set_image(url=membre.avatar.url)
    await ctx.send(embed=embed)

@bot.command()
async def join(ctx):
    """Le bot rejoint le salon vocal de l'utilisateur."""
    if ctx.author.voice:
        channel = ctx.author.voice.channel
        if ctx.voice_client:
            await ctx.voice_client.move_to(channel)
        else:
            await channel.connect()
        await ctx.send(f"‚úÖ Je viens de rejoindre {channel.mention} !")
    else:
        await ctx.send("‚ùå Tu dois √™tre dans un salon vocal pour utiliser cette commande.")

@bot.command()
async def leave(ctx):
    """Commande pour que le bot quitte le salon vocal s'il est seul."""
    voice_client = ctx.voice_client
    if voice_client and voice_client.is_connected():
        await voice_client.disconnect()
        await ctx.send("üëã D√©connect√© du salon vocal.")
    else:
        await ctx.send("‚ùå Le bot n'est pas dans un salon vocal.")

async def check_voice_channel():
    """V√©rifie si le bot est seul dans un salon vocal et le fait quitter apr√®s 60 secondes."""
    await bot.wait_until_ready()
    while not bot.is_closed():
        for guild in bot.guilds:
            voice_client = guild.voice_client
            if voice_client and voice_client.is_connected():
                channel = voice_client.channel
                members = [m for m in channel.members if not m.bot]

                if len(members) == 0:
                    await asyncio.sleep(60)
                    if len([m for m in channel.members if not m.bot]) == 0:
                        await voice_client.disconnect()
                        print(f"D√©connect√© du salon vocal {channel.name} car il √©tait vide.")
        await asyncio.sleep(30)

async def setup_hook():
    bot.loop.create_task(check_voice_channel())

bot.setup_hook = setup_hook

@bot.command()
async def play(ctx, url: str):
    """Lit une musique depuis un lien YouTube."""
    if not ctx.author.voice:
        await ctx.send("‚ùå Tu dois √™tre dans un salon vocal pour utiliser cette commande !")
        return
    
    voice_client = ctx.voice_client
    if not voice_client:
        voice_client = await ctx.author.voice.channel.connect()
    elif voice_client.is_playing():
        await ctx.send("üéµ Une musique est d√©j√† en cours ! Utilise `!stop` pour l'arr√™ter.")
        return
    
    await ctx.send("üîç Recherche de la musique...")

    ydl_opts = {
        "format": "bestaudio/best",
        "noplaylist": True,
        "postprocessors": [{
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": "192",
        }]
    }
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            audio_url = info["url"]
            title = info.get("title", "Musique inconnue")
    except Exception as e:
        await ctx.send(f"‚ùå Erreur lors de la r√©cup√©ration de la musique : {e}")
        return
    
    embed = discord.Embed(title="üé∂ Lecture en cours", description=f"**{title}**", color=discord.Color.blue())
    embed.set_footer(text=f"Demand√© par {ctx.author.name}", icon_url=ctx.author.avatar.url)
    await ctx.send(embed=embed)

    def after_play(error):
        if error:
            print(f"Erreur lors de la lecture : {error}")
    
    voice_client.play(discord.FFmpegPCMAudio(audio_url), after=after_play)

@bot.command()
async def stop(ctx):
    """Arr√™te la musique et fait quitter le bot du salon vocal."""
    voice_client = ctx.voice_client
    if voice_client:
        voice_client.stop()
        await voice_client.disconnect()
        await ctx.send("üõë Musique arr√™t√©e, bot d√©connect√©.")
    else:
        await ctx.send("‚ùå Le bot n'est pas dans un salon vocal.")

@bot.command()
async def cmds(ctx):
    """Affiche la liste des commandes disponibles sous forme d'embed."""
    embed = discord.Embed(title="üìú Liste des Commandes", description="Voici toutes les commandes disponibles :", color=discord.Color.blue())

    embed.add_field(name="üõ†Ô∏è Mod√©ration", value=(
        "`!roles` ‚Üí G√©rer les r√¥les\n"
        "`!ping` ‚Üí R√©pond avec üèì Pong !\n"
        "`!test_role @membre` ‚Üí Ajoute un r√¥le manuellement\n"
        "`!exclure @membre [raison]` ‚Üí Exclut un membre\n"
        "`!bannir @membre [raison]` ‚Üí Bannit un membre\n"
        "`!debannir ID_membre` ‚Üí D√©bannit un membre\n"
        "`!bannis` ‚Üí Liste des utilisateurs bannis\n"
        "`!clear` ‚Üí Supprime des messages\n"
    ), inline=False)

    embed.add_field(name="üé´ Tickets", value=(
        "`!setup_ticket` ‚Üí Cr√©e un message interactif pour ouvrir des tickets\n"
        "`!close` ‚Üí Ferme un ticket apr√®s 5 secondes\n"
    ), inline=False)

    embed.add_field(name="üìå R√©seaux Sociaux", value="`!lien` ‚Üí Affiche les liens vers mes r√©seaux sociaux", inline=False)

    embed.add_field(name="üé≠ Fun", value=(
        "`!blague` ‚Üí Envoie une blague al√©atoire\n"
        "`!avatar [@membre]` ‚Üí Affiche un avatar\n"
    ), inline=False)

    embed.add_field(name="üéµ Musique", value=(
        "`!join` ‚Üí Le bot rejoint le salon vocal\n"
        "`!leave` ‚Üí Le bot quitte le salon vocal\n"
        "`!play <URL YouTube>` ‚Üí Joue une musique\n"
        "`!stop` ‚Üí Arr√™te la musique\n"
    ), inline=False)

    embed.set_footer(text=f"Demand√© par {ctx.author.name}", icon_url=ctx.author.avatar.url)

    await ctx.send(embed=embed)

# ------------------------- √âV√âNEMENT : BOT PR√äT -------------------------
@bot.event
async def on_ready():
    print(f"‚úÖ {bot.user} est connect√© !")
    
    # ‚úÖ Ajoute la vue avec un event loop s√©curis√©
    asyncio.create_task(register_views())

    # ‚úÖ Envoie automatique du r√®glement
    guild = bot.get_guild(GUILD_ID)
    if guild:
        await send_rules_channel(guild)

async def register_views():
    await bot.wait_until_ready()  # ‚úÖ Attend que le bot soit totalement pr√™t
    bot.add_view(RoleView())  # ‚úÖ Ajoute la vue proprement

for guild in bot.guilds:
    for channel in guild.text_channels:
        print(f"{repr(channel.name)} - {channel.id}")

# ------------------------- LANCEMENT DU BOT -------------------------

if TOKEN is None:
    print("‚ùå Erreur : DISCORD_TOKEN est introuvable ! Assurez-vous qu'il est bien d√©fini dans votre environnement.")
    exit(1)  # Arr√™te le programme proprement
else:
    print("‚úÖ Token r√©cup√©r√© avec succ√®s.")

bot = discord.Client(intents=discord.Intents.default())

bot.run(TOKEN)
